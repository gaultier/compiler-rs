<!DOCTYPE html>
<html>
<head>
<title>Live compiler</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="main.css">
</head>
    <body>
        <div class="container">
            <textarea id="input" default="123 + 456"></textarea>
            <div id="errors"></div>
            <div id="lex"></div>
            <div id="parse"></div>
            <div id="ir"></div>
            <div id="ir_eval"></div>
            <div id="regalloc"></div>
            <div id="asm"></div>
            <div id="asm_eval"></div>
        </div>
    </body>
    <script>
        const amd64_reg_to_string = {
            0: "rax",
            1: "rbx",
            2: "rcx",
            3: "rdx",
            4: "rdi",
            5: "rsi",
            6: "r8",
            7: "r9",
            8: "r10",
            9: "r11",
            10: "r12",
            11: "r13",
            12: "r14",
            13: "r15",
            14: "rbp",
            15: "rsp",
        };

        function utf16_to_utf8(str) {
            const encoder = new TextEncoder();
            return encoder.encode(str);
        }

        function utf8_to_utf16(bytes) {
            const decoder = new TextDecoder('utf-8');
            return decoder.decode(bytes);
        }

        function run(input_js, wasm_instance) {
            console.log("input:",input_js);
            const ts_start = performance.now();
            const exports = wasm_instance.exports;
            const memory = exports.memory;

            let input_bytes = utf16_to_utf8(input_js);
            const input_len = input_bytes.length;
            const input_ptr = exports.alloc_u8(input_len)

            const input_mem = new Uint8Array(memory.buffer, input_ptr, input_len);
            input_mem.set(input_bytes); // memcpy.

            const handle = exports.wasm_compile(input_ptr, input_len, 1); 
            const handle_ptr = Number(handle >> 32n);
            const handle_len = Number(handle & 0xffffffffn);
            console.log("handle:",handle_ptr, handle_len);
            
            const res_slice = new Uint8Array(memory.buffer, handle_ptr, handle_len);
            const res_str = utf8_to_utf16(res_slice);

            const res = JSON.parse(res_str); 
            console.log("compiled:",res);
            console.log("total alloc size: ",exports.alloc_get_size());

            //exports.dealloc_u8_no_metadata(input_ptr, input_len);
            //exports.dealloc(handle);
            const ts_end = performance.now();
            console.log("run time: ", ts_end - ts_start, " ms");

            const errors_dom = document.getElementById("errors");
            errors_dom.innerHTML ="";
            for (const err of res.errors) {
                const err_dom = document.createElement("div");
                err_dom.classList.add("error");
                err_dom.innerHTML = `
                    <span>Kind: ${err.kind}</span>
                    <span>Line: ${err.origin.line}</span>
                    <span>Column: ${err.origin.column}</span>
                    <span>Offset: ${err.origin.offset}</span>
                    <span>Explanation: ${err.explanation}</span>
                `;

                errors_dom.appendChild(err_dom);
            }

            const lex_dom = document.getElementById("lex");
            lex_dom.innerHTML ="";
            for (const token of res.lex_tokens) {
                const span_bytes = input_bytes.subarray(token.origin.offset, token.origin.offset + token.origin.len);
                // TODO: Should we just maintain a mapping in JS of utf8 offset -> utf16 offset? 
                // Or return utf16 offsets from WASM directly?
                const span_js_string = token.kind == "Eof" ? "EOF" : utf8_to_utf16(span_bytes);
                const token_dom = document.createElement("span");
                token_dom.classList.add("token");
                token_dom.innerText = span_js_string;

                lex_dom.appendChild(token_dom);
            }

            const parse_dom = document.getElementById("parse");
            parse_dom.innerHTML ="";
            for (const node of res.ast_nodes) {
                const node_dom = document.createElement("span");
                node_dom.classList.add("ast_node");
                node_dom.innerText = node.kind;
                if (node.data && node.data.Num != null) {
                    node_dom.innerText += `(${node.data.Num})`;
                }
                if (node.data && node.data.Bool != null) {
                    node_dom.innerText += `(${node.data.Bool})`;
                }
                parse_dom.appendChild(node_dom);
            }

            const ir_dom = document.getElementById("ir");
            ir_dom.innerText = res.ir_text;

            const ir_eval_dom = document.getElementById("ir_eval");
            ir_eval_dom.innerText = '';
            for (const [vreg, val] of Object.entries(res.ir_eval)) {
                const item = document.createElement("span");
                item.innerText = `v${vreg}: `
                if (val.kind.Num != null) {
                    item.innerText += `${val.kind.Num}`;
                } else if (val.kind.Bool != null) {
                    item.innerText += `${val.kind.Bool}`;
                }

                ir_eval_dom.appendChild(item);
            }

            const regalloc_dom = document.getElementById("regalloc");
            regalloc_dom.innerHTML = '';
            for (const [vreg, memory_location] of Object.entries(res.vreg_to_memory_location)) {
                const item_dom = document.createElement("span");
                item_dom.classList.add("regalloc_item");

                if (memory_location.Register.Amd64 != null) {
                    item_dom.innerText = `v${vreg} -> ${memory_location.Register.Amd64}`;
                } else {
                    item_dom.innerText = `v${vreg} -> S[${memory_location.Stack}]`;
                }

                regalloc_dom.appendChild(item_dom);
            }

            const asm_dom = document.getElementById("asm");
            asm_dom.innerText = res.asm_text;

            const asm_eval_dom = document.getElementById("asm_eval");
            asm_eval_dom.innerText = "";
            for (const [mem_loc, val] of res.asm_eval) {
                const item = document.createElement("span");
                if (mem_loc.Register != null && mem_loc.Register.Amd64 != null) {
                    item.innerText = `${mem_loc.Register.Amd64}: ${val.kind.Num}`;
                } else if (mem_loc.Stack != null) {
                    item.innerText = `stack ${mem_loc.Stack}: ${val.kind.Num}`;
                }

                asm_eval_dom.appendChild(item);
            }
        }

        async function loadWasm() {
            // Parameters here are page counts. A page is 64 KiB big.
            // So: 1MiB.
            const memory = new WebAssembly.Memory({ initial: 16, maximum: 16 });

            //    const importsObject = createImports(memory);

            try {
                // TODO: Fetch release build.
                const result = await WebAssembly.instantiateStreaming(
                    fetch("target/wasm32-unknown-unknown/release/compiler_rs_lib.wasm"),
                    //importsObject // Provide the required imports (host functions, memory)
                );

                console.log("WebAssembly module loaded and instantiated successfully.", result.instance.exports);

                const input_dom = document.getElementById("input");
                try {
                    run(input_dom.value, result.instance);
                } catch(error) {
                    console.error("Error running WASM:", error);
                }
                input_dom.addEventListener('input', function(event) {
                    try {
                        run(event.target.value, result.instance);
                    } catch(error) {
                        console.error("Error running WASM:", error);
                    }
                });
            } catch (error) {
                console.error("Error loading WASM:", error);
            }
        }

        // Start the loading process
        loadWasm();
    </script>
</html>
