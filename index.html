<!DOCTYPE html>
<html>
<head>
<title>Live compiler</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="main.css">
</head>
    <body>
        <div class="container">
        <textarea id="input" default="123 + 456"></textarea>
        <pre>
            <code id="json_pretty"></code>
        </pre>
        <div id="lexed"></div>
        </div>
    </body>
    <script>
        function JsStringToUtf8Bytes(str) {
            const encoder = new TextEncoder();
            return encoder.encode(str);
        }

        function Utf8BytesToJsString(bytes) {
            const decoder = new TextDecoder('utf-8');
            return decoder.decode(bytes);
        }

        function run(input_js, wasm_instance) {
            const ts_start = performance.now();
            const exports = wasm_instance.exports;
            const memory = exports.memory;

            let input_bytes = JsStringToUtf8Bytes(input_js);
            const input_len = input_bytes.length;
            const input_ptr = exports.alloc_u8_no_metadata(input_len)
            const input_mem = new Uint8Array(memory.buffer, input_ptr, input_len);
            input_mem.set(input_bytes); // memcpy.

            const handle = exports.parse(input_ptr, input_len, 1); 
            const res_slice_len = new Uint8Array(memory.buffer, handle, 4);
            const len = res_slice_len[0] | res_slice_len[1]<<8 | res_slice_len[2]<<16 | res_slice_len[3]<<24;

            const res_slice = new Uint8Array(memory.buffer, handle + 9, len);
            const res_str = Utf8BytesToJsString(res_slice);

            const res = JSON.parse(res_str); 
            const res_json_pretty = JSON.stringify(res, null, 2); 

            exports.dealloc_u8_no_metadata(input_ptr, input_len);
            exports.dealloc(handle);
            const ts_end = performance.now();
            console.log("run time: ", ts_end - ts_start, " ms");

            const json_dom = document.getElementById("json_pretty");
            json_dom.innerText = res_json_pretty;


            const lexed_dom = document.getElementById("lexed");
            lexed_dom.innerHTML ="";
            for (const token of res.tokens) {
                const span_bytes = input_bytes.subarray(token.origin.offset, token.origin.offset + token.origin.len);
                // TODO: Should we just maintain a mapping in JS of utf8 offset -> utf16 offset? 
                // Or return utf16 offsets from WASM directly?
                const span_js_string = token.kind == "Eof" ? "EOF" : Utf8BytesToJsString(span_bytes);
                lexed_dom.innerHTML += `<span class="token" data-src="${token.kind}">${span_js_string}</span>`;
            }


        }

        async function loadWasm() {
            // Parameters here are page counts. A page is 64 KiB big.
            const memory = new WebAssembly.Memory({ initial: 1, maximum: 1 });

            //    const importsObject = createImports(memory);

            try {
                // TODO: Fetch release build.
                const result = await WebAssembly.instantiateStreaming(
                    fetch("target/wasm32-unknown-unknown/debug/compiler_rs_lib.wasm"),
                    //importsObject // Provide the required imports (host functions, memory)
                );

                console.log("WebAssembly module loaded and instantiated successfully.", result.instance.exports);

                const input_dom = document.getElementById("input");
                run(input_dom.value, result.instance);
                input_dom.addEventListener('input', function(event) {
                    run(event.target.value, result.instance);
                });
            } catch (error) {
                console.error("Error loading or running WASM:", error);
            }
        }

        // Start the loading process
        loadWasm();
    </script>
</html>
